<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RISEOffline</title>
  <link rel="icon" href="https://fonts.gstatic.com/s/e/notoemoji/latest/1f305/512.gif" type="image/gif">
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="toc">
    <h3>Content</h3>
    <hr>
    <ul>
      <li><a href="#abstract">Abstract</a></li>
      <li><a href="#deploy-in-real">Real-world Demo</a></li>
      <li><a href="#approach">Approach</a></li>
      <li class="toc-subsection"><a href="#spectral norm">Non-expert Data</a></li>
      <li class="toc-subsection"><a href="#training-in-sim">Offline RL</a></li>
      <li class="toc-subsection"><a href="#spectral norm">Lipschitz Continuity</a></li>
      <li><a href="#acknowledgements">Acknowledgements</a></li>
    </ul>
  </div>

  <div class="main-content">
    <div class="hero-text">RISE
    <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f305/512.gif" alt="ðŸŒ…" style="display:inline-block; width:64px; height:64px; box-shadow:none; border:none; background:none; vertical-align:middle;">
    </div>
    <div class="sub-hero-text">Using Non-Expert Data to Robustify Imitation
Learning via Offline Reinforcement Learning</div>

    <!-- Add Authors -->
    <div class="authors">
      <a href="https://kevinhuang8.github.io/" target="_blank">Kevin Huang*</a>, <a href="https://rosari.ooo/" target="_blank">Rosario Scalise*</a>,
      Cleah Winston,
      Yunchu Zhang,
      Rohan Baijal, 
      Ayush Agrawal,
      Markus Grotz,
      Bryon Boots,
      Abhishek Gupta
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*:equal contribution)
      <span class="affiliation">University of Washington</span>
      Benjamin Burchfiel,
      Hongkai Dai,
      Masha Itkina,
      Paarth Shah
      <span class="affiliation">Toyota Research Institute</span>
    </div>
    <!-- End Authors -->

    <video id="teaser-video" src="./figs/teaser.mp4" width="100%" height="100%" controls muted playsinline autoplay></video>
    <!-- Caption for Figure 1 (Teaser Video) -->
    <p class="figure-caption">
        <span style="font-variant: small-caps;">RISE</span>: Robust Imitation by Stiching from Experts demonstrates the following benefits.
    </p>

    <!-- Add Quick Links Here -->
    <div class="quick-links">
      <a href="./todo.pdf" target="_blank">[pdf]</a>
      <a href="https://github.com/UWRobotlearning" target="_blank">[arxiv]</a>
      <a href="https://github.com/UWRobotlearning">[code(soon)]</a> 
      <!-- <a href="#gallery-section-anchor">[gallery]</a> -->
    </div>
    
    <div class="tagline" id="abstract">Abstract.</div>


    <div class="section">

        Imitation learning has proven highly effective for training robots to
        perform complex tasks from expert human demonstrations. However, it remains
        limited by reliance on high-quality, task-specific data, restricting adaptability to
        the diverse range of real-world object configurations and scenarios. In contrast,
        non-expert dataâ€”such as play data, suboptimal demonstrations, or partial task
        completionsâ€”can offer broader coverage and lower collection costs, but conven-
        tional imitation learning approaches fail to utilize this data effectively. To address
        these challenges, we show that offline reinforcement learning can be used as a
        tool to harness non-expert data to enhance the performance of imitation learning
        policies. We show that while standard offline RL approaches can be ineffective
        at actually leveraging non-expert data under sparse coverage, simple algorithmic
        modifications can allow the utilization of this data without significant additional
        assumptions. Our approach shows that broadening the support of the policy dis-
        tribution in offline RL can allow offline RL augmented imitation algorithms to
        solve tasks robustly, under sparse coverage. In manipulation tasks, these innova-
        tions significantly increase the range of states where learned policies are success-
        ful when non-expert data is incorporated. Moreover, we show that these methods
        are able to leverage all collected data, including partial or suboptimal demonstra-
        tions, to bolster task-directed policy performance, underscoring the importance of
        methods for using non-expert data for scalable and robust robot learning.
        We introduce <b>R</b>obust <b>I</b>mitation Learning by <b>S</b>titching from <b>E</b>xperts,
        or <span style="font-variant: small-caps;">RISE</span> ðŸŒ…. 
    
    </div> 

    <div class="tagline" id="deploy-in-real">Real-world Demo.</div>

  <!-- VIDEO GALLERIES -->

  <!-- Video Gallery Section - TIPPING VIDEOS -->
    <div class="video-gallery-section" id="tippingGallerySection">
      <div class="video-gallery-container">
        <div class="video-gallery" id="videoGalleryTipping">
          <!-- Videos remain here - ADD autoplay -->
          <video class="gallery-video" src="./tipping/Tipping_DATA.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./tipping/Tipping_Recover_From_Failure.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./tipping/Tipping_Single_Disturbance_BCU.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./tipping/Tipping_Single_Disturbance.mp4" autoplay muted playsinline loop></video>
          <!--- Insert more videos here!!!!-->
          <!-- Add more videos as needed, ensuring they have autoplay muted loop -->
        </div>
      </div>
      <!-- Container for the caption AND buttons -->
      <div class="gallery-caption-container">
          <!-- Move button controls INSIDE caption container -->
          <div class="gallery-nav-controls">
              <button class="gallery-nav left" id="scrollLeftBtnTraversing">&lt;</button>
              <button class="gallery-nav right" id="scrollRightBtnTraversing">&gt;</button>
          </div>
          <!-- Caption text -->
          <p class="figure-caption gallery-caption">
              <b>Tipping:</b> Yada yada.
          </p>
      </div>
    </div>

  <!-- Video Gallery Section - Cloth VIDEOS -->
    <div class="video-gallery-section" id="ClothGallerySection">
      <div class="video-gallery-container">
        <div class="video-gallery" id="videoGalleryCloth">
          <!-- Videos remain here - ADD autoplay -->
          <video class="gallery-video" src="./cloth/Cloth_Fold_DATA.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./cloth/Cloth_Fold.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./cloth/Cloth_Stack_DATA.mp4" autoplay muted playsinline loop></video>
          <video class="gallery-video" src="./cloth/Cloth_Stack.mp4" autoplay muted playsinline loop></video>
          <!--- Insert more videos here!!!!-->
          <!-- Add more videos as needed, ensuring they have autoplay muted loop -->
        </div>
      </div>
      <!-- Container for the caption AND buttons -->
      <div class="gallery-caption-container">
          <!-- Move button controls INSIDE caption container -->
          <div class="gallery-nav-controls">
              <button class="gallery-nav left" id="scrollLeftBtnTraversing">&lt;</button>
              <button class="gallery-nav right" id="scrollRightBtnTraversing">&gt;</button>
          </div>
          <!-- Caption text -->
          <p class="figure-caption gallery-caption">
              <b>Cloth:</b> Yada yada.
          </p>
      </div>
    </div>
  <!-- End Video Gallery Section -->


  <!-- APPROACH -->
    <div class="tagline" id="approach">Approach.</div>
    <div class="section" style="margin-top: -5px;">
      <p>
        Figures explaining.
      </p>
    </div>


    <!-- Container for the caption AND buttons -->
    <div class="gallery-caption-container">
        <!-- Move button controls INSIDE caption container -->
        <div class="gallery-nav-controls">
            <button class="gallery-nav left" id="scrollLeftBtnReconstruction">&lt;</button>
            <button class="gallery-nav right" id="scrollRightBtnReconstruction">&gt;</button>
        </div>
        <!-- Caption text -->
        <p class="figure-caption gallery-caption" style="margin-bottom: 30px;">
            <b>Test:</b> A caption.
        </p>
    </div>
  <!-- End Video Gallery Section -->

    <a id="figure-1-img" href="figs/2.png" download="2.png">
      <img src="figs/2-min.png" alt="real-to-sim pipeline">
    </a>
    <!-- Caption for Figure 2 -->
    <p class="figure-caption">
      <b>Figure 1:</b> Another.
    </p>

    <a id="figure-2-img" href="figs/4.png" download="4.png">
      <img src="figs/4-min.png" alt="Approach Overview">
    </a>
    <!-- Caption for Figure 2 -->
    <p class="figure-caption">
      <b>Figure 2:</b> Another.
    </p>

    <div class="section-subtitle" id="lipschitz">2. Lipschitz.</div>

    <a id="figure-3-img" href="figs/3.png" download="3.png">
      <img src="figs/3-min.png" alt="Training in Sim">
    </a>
    <!-- Caption for Figure 3 -->
    <p class="figure-caption">
      <b>Figure 3:</b> Another.
    </p>



    <div class="tagline" id="acknowledgements">Acknowledgements.</div>
    <div class="section" style="margin-top: -5px;">
      <p>
        We thank .
      </p>
    </div>

    <div class="bibtex-code" id="bibtex">
      <div class="bibtex-title">BibTeX</div>
      <pre><code>Insert bibtex here.
        }</code></pre>
    </div>

  </div> <!-- End of main-content div -->


  <div class="footer">
     Â© UW | Adapted from design by the <span style="font-variant: small-caps;">VideoMimic</span> team. Source code available <a href="https://github.com/videomimic-1/videomimic-1.github.io" target="_blank">here</a>.
  </div>

  <!-- Teaser Video Autoplay with Delay and Loop -->
  <script>
  document.addEventListener('DOMContentLoaded', function() {
    const video = document.getElementById('teaser-video');
    // const initialDelay = 1000; // No longer needed, autoplay attribute handles initial play
    const loopDelay = 3000;    // 3 seconds delay before looping

    // let initialPlayTimeout; // No longer needed
    let loopTimeout;

    if (video) {
      // Ensure video is muted (already in HTML, but good practice)
      video.muted = true;
      // Controls are already in HTML, ensuring user can play if autoplay fails

      // REMOVE JavaScript-based initial play:
      /*
      initialPlayTimeout = setTimeout(function() {
        video.play().then(function() {
          // Autoplay started
        }).catch(function(error) {
          console.log('Initial autoplay prevented for teaser video. User interaction might be needed.', error);
          video.controls = true; // Ensure controls are visible
        });
      }, initialDelay);
      */

      // Loop with delay - this part can stay
      video.addEventListener('ended', function() {
        clearTimeout(loopTimeout); 
        loopTimeout = setTimeout(function() {
          video.currentTime = 0; 
          video.play().catch(function(error) {
            console.log('Delayed loop play prevented for teaser video:', error);
          });
        }, loopDelay);
      });

      // --- Clear Timeouts on Manual Pause ---
      video.addEventListener('pause', function() {
        if (!video.ended && video.currentTime > 0) {
           // clearTimeout(initialPlayTimeout); // No longer needed
           clearTimeout(loopTimeout);
           console.log('Teaser video: Manual pause detected, clearing loop timeout.');
        }
      });

      // --- Clear Timeouts on Manual Play (if paused before initial delay finishes) ---
       video.addEventListener('play', function() {
           // if (initialPlayTimeout) { // No longer needed
           //     clearTimeout(initialPlayTimeout);
           // }
       });

    } else {
      console.error('Video element with ID "teaser-video" not found.');
    }
  });
  </script>

  <!-- JavaScript for Video Gallery Navigation -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const galleries = [
        {
          sectionId: 'gallery-section-anchor', // ID of the .video-gallery-section for sitting
          galleryInnerId: 'videoGallerySitting',
          scrollLeftBtnId: 'scrollLeftBtnSitting',
          scrollRightBtnId: 'scrollRightBtnSitting'
        },
        {
          sectionId: 'traversingGallerySection', // ID of the .video-gallery-section for traversing
          galleryInnerId: 'videoGalleryTraversing',
          scrollLeftBtnId: 'scrollLeftBtnTraversing',
          scrollRightBtnId: 'scrollRightBtnTraversing'
        },
        {
          sectionId: 'stairsGallerySection', // ID of the .video-gallery-section for stairs
          galleryInnerId: 'videoGalleryStairs',
          scrollLeftBtnId: 'scrollLeftBtnStairs',
          scrollRightBtnId: 'scrollRightBtnStairs'
        },
        {
          sectionId: 'reconstructionGallerySection', // ID of the .video-gallery-section for reconstruction
          galleryInnerId: 'videoGalleryReconstruction',
          scrollLeftBtnId: 'scrollLeftBtnReconstruction',
          scrollRightBtnId: 'scrollRightBtnReconstruction'
        }
      ];

      galleries.forEach(galleryConfig => {
        const gallerySection = document.getElementById(galleryConfig.sectionId);
        if (!gallerySection) {
          console.error(`Gallery section with ID ${galleryConfig.sectionId} not found.`);
          return;
        }

        const galleryContainer = gallerySection.querySelector('.video-gallery-container');
        const galleryInner = document.getElementById(galleryConfig.galleryInnerId);
        const scrollLeftBtn = document.getElementById(galleryConfig.scrollLeftBtnId);
        const scrollRightBtn = document.getElementById(galleryConfig.scrollRightBtnId);

        if (galleryContainer && galleryInner && scrollLeftBtn && scrollRightBtn) {
          // Calculate the scroll amount based on the width of the first video + gap
          const scrollAmount = (galleryInner.firstElementChild?.offsetWidth || 300) + 15; // 15 is the gap

          scrollLeftBtn.addEventListener('click', () => {
            // Scroll the CONTAINER element
            galleryContainer.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
          });

          scrollRightBtn.addEventListener('click', () => {
            // Scroll the CONTAINER element
            galleryContainer.scrollBy({ left: scrollAmount, behavior: 'smooth' });
          });

          /* --- REMOVE OR COMMENT OUT HOVER LOGIC ---
          // Optional: Add hover-to-play functionality for gallery videos
          // Target videos within galleryInner
          const galleryVideos = galleryInner.querySelectorAll('.gallery-video');
          galleryVideos.forEach(video => {
              video.addEventListener('mouseenter', () => {
                  video.play().catch(e => console.log("Autoplay prevented:", e));
              });
              video.addEventListener('mouseleave', () => {
                  video.pause();
                  // video.currentTime = 0; // Optional: reset video on mouse leave
              });
          });
          */ // --- END OF REMOVED HOVER LOGIC ---

        } else {
          console.error(`Gallery elements not found for navigation setup in section ${galleryConfig.sectionId}.`);
          // Log which elements might be missing
          if (!galleryContainer) console.error('Missing element: .video-gallery-container in section ' + galleryConfig.sectionId);
          if (!galleryInner) console.error(`Missing element with ID ${galleryConfig.galleryInnerId}`);
          if (!scrollLeftBtn) console.error(`Missing element with ID ${galleryConfig.scrollLeftBtnId}`);
          if (!scrollRightBtn) console.error(`Missing element with ID ${galleryConfig.scrollRightBtnId}`);
        }
      });
    });
  </script>

  <!-- JavaScript for Real-to-Sim Video Synchronization -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const videosToSync = [
        document.querySelector('.r2s-video-input'),
        document.querySelector('.r2s-video-smpl'),
        document.querySelector('.r2s-video-g1'),
        document.querySelector('.r2s-video-ego-rgb'),
        document.querySelector('.r2s-video-ego-depth'),
        document.querySelector('.r2s-video-sim')
      ].filter(Boolean); // Filter out nulls if any class name is wrong or video missing

      function synchronizeAndPlayR2SVideos() {
        if (videosToSync.length === 0) {
          console.warn('No videos found for Real-to-Sim synchronization.');
          return;
        }

        const readyPromises = videosToSync.map(video => {
          return new Promise((resolve, reject) => {
            // If video is already ready (e.g., cached), resolve immediately
            if (video.readyState >= 4) { // HAVE_ENOUGH_DATA (canplaythrough)
              resolve();
            } else {
              video.addEventListener('canplaythrough', resolve, { once: true });
              video.addEventListener('error', reject, { once: true }); // Handle potential loading errors
            }
          });
        });

        Promise.all(readyPromises)
          .then(() => {
            console.log('All Real-to-Sim videos are ready to play. Starting playback.');
            videosToSync.forEach(video => {
              video.currentTime = 0; // Ensure starting from the beginning
              video.play().catch(error => {
                console.warn(`Autoplay was prevented for video ${video.src}. User interaction might be needed.`, error);
                // Ensure controls are visible if autoplay fails for any video
                video.controls = true;
              });
            });
          })
          .catch(error => {
            console.error('Error waiting for Real-to-Sim videos to be ready:', error);
            // Optionally, provide a fallback or user message here
            videosToSync.forEach(video => video.controls = true); // Show controls on all if any failed to load
          });
      }

      synchronizeAndPlayR2SVideos();

      // The `loop` attribute on the HTML video tags will handle continuous looping.
      // The videos will naturally re-synchronize at their LCM due to the loop attribute
      // if they have different durations and all successfully start.
    });
  </script>

  <!-- JavaScript to prevent default click on specific image links -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const imageLinkIds = ['figure-1-img', 'figure-2-img', 'figure-3-img'];
      imageLinkIds.forEach(id => {
        const linkElement = document.getElementById(id);
        if (linkElement) {
          linkElement.addEventListener('click', function(event) {
            event.preventDefault();
          });
        }
      });
    });
  </script>

</body>
</html>
